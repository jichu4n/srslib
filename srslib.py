# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#                                                                             #
#    Copyright (C) 2017 Chuan Ji <jichu4n@gmail.com>                          #
#                                                                             #
#    Licensed under the Apache License, Version 2.0 (the "License");          #
#    you may not use this file except in compliance with the License.         #
#    You may obtain a copy of the License at                                  #
#                                                                             #
#     http://www.apache.org/licenses/LICENSE-2.0                              #
#                                                                             #
#    Unless required by applicable law or agreed to in writing, software      #
#    distributed under the License is distributed on an "AS IS" BASIS,        #
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. #
#    See the License for the specific language governing permissions and      #
#    limitations under the License.                                           #
#                                                                             #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
"""Python SRS (Sender Rewriting Scheme) library."""

import base64
import datetime
import hashlib
import hmac
import re
import string
import time


class SRS(object):
  """A SRS (Sender Rewriting Scheme) configuration instance.

  This class implements the Guarded scheme described in the original SRS paper
  at http://www.libsrs2.org/srs/srs.pdf, with sensible defaults derived from the
  the canonical libsrs2 C implementation.

  Example usage:

    srs = SRS('secret_key')
    # Rewrites an email from alice@A.com to B.com
    rewritten_from = srs.forward('alice@A.com', 'B.com')
    # Reverse it
    bounce_to = srs.reverse(rewritten_from)
  """

  # Regular expression matching SRS0 and SRS1 addresses.
  _SRS0 = re.compile(r"""
      SRS0          # Prefix tag
      ([-+=].+)     # Opaque part w/ leading separator, generated by 1st hop
      """, re.IGNORECASE | re.VERBOSE)
  _SRS1 = re.compile(r"""
      SRS1          # Prefix tag
      [-+=]
      ([^=]+)       # Hash
      =
      ([^=]+)       # 1st hop host
      =
      ([-+=].+)     # Opaque part w/ leading separator, generated by 1st hop
      """, re.IGNORECASE | re.VERBOSE)
  # 5-bit / base 32 alphabet for timestamp encoding as described in the spec.
  # Note that this is NOT the same as RFC4648 or RFC3548 Base32 encoding, which 
  # are both 8-bit / base 256 encodings.
  _TS_ALPHABET = string.ascii_uppercase + '234567'

  def __init__(
      self,
      secret,
      reverse_secrets=[],
      reverse_limit_days=21,
      hash_length=4):
    """Creates a new SRS configuration instance.

    Args:
      secret: Cryptographic secret for creating / reversing rewritten addresses.
      reverse_secrets: Additional secrets for reversing rewritten addresses.
      reverse_limit_days: Number of days after which rewritten addresses cannot
        be reversed.
      hash_length: Length to truncate hash digest to.
    """
    self._secret = secret
    self._reverse_secrets = reverse_secrets
    self._reverse_limit_days = reverse_limit_days
    self._hash_length = hash_length

  def forward(self, from_addr, alias_host):
    """Rewrites sender address from_addr to alias_host.

    Args:
      from_addr: The original "From:" address.
      alias_host: The host to rewrite to (current host).
    """
    try:
      from_local_part, from_host = from_addr.split('@')
    except ValueError:
      raise ValueError('Invalid from_addr address: "%s"' % from_addr)

    # Case 1: Address is an SRS1 address. We are hop > 2, and we replace the
    # hash with our own to generate a new SRS1 address that also bounces to the
    # 1st hop.
    m = self._SRS1.match(from_local_part)
    if m:
      return self.generate_srs1_address(m.group(2), m.group(3), alias_host)

    # Case 2: Address is an SRS0 address. We are the 2nd hop, and we will return
    # an SRS1 address that bounces to the 1st hop.
    m = self._SRS0.match(from_local_part)
    if m:
      return self.generate_srs1_address(from_host, m.group(1), alias_host)

    # Case 3: We are the 1st hop. We will return an SRS0 address.
    return self.generate_srs0_address(from_host, from_local_part, alias_host)

  def generate_srs0_address(
      self, orig_host, orig_local_part, alias_host):
    """Produces an SRS0 address.

    Args:
      orig_host: Host part of the original "From:" address.
      orig_local_part: Local part of the original "From:" address.
      alias_host: The host to rewrite to (current host).
    """
    ts = self._generate_ts()
    return 'SRS0=%s=%s=%s=%s@%s' % (
        self._hash(ts + orig_host + orig_local_part),
        ts,
        orig_host,
        orig_local_part,
        alias_host)

  def generate_srs1_address(
      self, first_hop_host, first_hop_local_part, alias_host):
    """Produces an SRS1 address.

    Args:
      first_hop_host: Address of the 1st hop (SRS0) host.
      first_hop_local_part: Local part generated by 1st host (w/o "SRS0" prefix)
      alias_host: The host to rewrite to (current host).
    """
    return 'SRS1=%s=%s=%s@%s' % (
        self._hash(first_hop_host + first_hop_local_part),
        first_hop_host,
        first_hop_local_part,
        alias_host)

  def _hash(self, s):
    """Produces a hash string for use in an SRS address.

    As recommended in the specification, this function yields a base64-encoded
    hash of the provided string in lower case using the HMAC-SHA1 algorithm, and
    truncates it to hash_length characters.
    """
    return (
        base64.b64encode(
            hmac.new(self._secret, s.lower().encode('utf-8'), hashlib.sha1)
            .digest())
        [:self._hash_length]
        .decode('utf-8'))

  def _generate_ts(self, t=None):
    """Produces a timestamp for use in an SRS0 address.

    Following the algorithm in the original paper, this function yields the UNIX
    timestamp of the current date modded by 2^10, encoded in base32.

    Args:
      t: If not None, specifies the UNIX timestamp to use instead of the current
        time.
    """
    t = int((t or time.time()) // datetime.timedelta(days=1).total_seconds())
    return ''.join(
        self._TS_ALPHABET[x]
        for x in (
            (t >> 5) & 0b11111,
            t & 0b11111,
        ))

